'use strict';

const extend = require('extend');
const helper = require('node-red-viseo-helper');

let getUserAddress = exports.getUserAddress = function(data){
    return helper.getByString(data, 'user.address', undefined)
}

//user.address.conversation.id shouldn't be overriden by subsequent database requests if the "merge" option is ticked
let getConvId = exports.getConvId = function(data) {
    return helper.getByString(data, 'user.address.conversation.id', undefined)
}

let getUserProfile = exports.getUserProfile = function(data) {
    if (!data.user) data.user = {};
    if (!data.user.profile) data.user.profile = {};
    return data.user.profile;
}

let getLocale = exports.getLocale = function(data) {
    let profile = getUserProfile(data);
    return profile.locale || 'fr_FR';
}

let _CONTEXTS = {};
let getContext = exports.getContext = function(data) {

    let convId = getConvId(data);
    let context = _CONTEXTS[convId];

    if(!context) {
        context = _CONTEXTS[convId] = {};
    }

    return context;
}

// ------------------------------------------
//  CALLBACK DELAYED (PROMPT)
// ------------------------------------------

let DELAYED_CALLBACK = {}
function listenEnd(srcNode, data, srcConfig) {
    var id = getConvId(data);
	delete DELAYED_CALLBACK[id];
}

helper.listenEvent('endConversation', listenEnd);

let delayCallback = exports.delayCallback = function(id, callback) {
    if (!id) return;
    DELAYED_CALLBACK[id] = callback;
}

let hasDelayedCallback = exports.hasDelayedCallback = function(id, data) {
    if (!id) return;

    let callback = DELAYED_CALLBACK[id];
    if (undefined === callback) return false;

    delete DELAYED_CALLBACK[id];
    callback(data);
    return true;
}

// ------------------------------------------
//  BOT MESSAGE
// ------------------------------------------

let buildMessageFlow = exports.buildMessageFlow = function(data, config) {
    
    data = data || {}
    let msg  = data.message = data.message || {}
    
    if (config.source) msg.source = msg.source || config.source;
    if (config.agent)  msg.agent  = msg.agent  || config.agent;
    msg.attachments = msg.attachments || [];

    msg.address = msg.address || {}
    msg.address.carrier = msg.address.carrier || config.agent || config.source
    msg.address.conversation = msg.address.conversation || {}
    msg.address.conversation.id = helper.getByString(data, config.convId, msg.address.conversation.id || 'UnknowId');

    msg.user      = msg.user || {}
    msg.user.id   = helper.getByString(data, config.userId, msg.user.id     || 'UnknownId');
    msg.user.name = helper.getByString(data, config.userName, msg.user.name || 'Unknown');

    data.user = data.user || {}
    data.user.address = data.user.address || {}
    data.user.profile = data.user.profile || {}
    extend(true, data.user, msg.user);
    extend(true, data.user.address, msg.address);

    if (config.payload){
        let payload = helper.getByString(data, config.payload,  'Unknown Payload');
        data.payload = payload
    }
    if (data.payload){ // warn can be tricky if it's an irevelant payload
        msg.text = msg.text || data.payload
    }

    if (config.context){
        let currentContext = getContext(data)
        let ctxt = helper.getByString(data, config.context, undefined);
        extend(true, currentContext, ctxt);
    }
    
    return data;
}

/*
 * Skeleton for message class
 * Abstract, meant to be extended by classes to handle Messenger, Skype, etc. messages.
 */
exports.MessageManager = class MessageManager {

    constructor(node) {
        if (this.constructor === MessageManager) {
            throw new TypeError('abstract class "MessageManager" cannot be instantiated directly.'); 
        }
        this.type = node.type;
        this.buttonsStack = {
            push: function(data, buttons) {
                if (!data._buttonsStack) data._buttonsStack = [];
                data._buttonsStack = data._buttonsStack.concat(buttons);
            },
            get: function(data, index) {
                let btns = data._buttonsStack || [];
                if (!index) return btns;
                else if (btns.length > index) return btns[index];
                else return null;
            },
            clear: function(data) {
                data._buttonsStack = []; 
            }
        };
        this.prepareSend = function(RED, node, data, config) {

            if (this.isPrompt(config)) {
                // Get the output number to send to
                let outNumber = this.getOutputNumber(RED, node, data, config);
    
                // If 0, ithe prompted text doesn't match any button and wasn't expected...
                if (!outNumber || outNumber === 0) {
                    helper.emitAsyncEvent('prompt', node, data, config, (data) => {
                        helper.emitAsyncEvent('prompt-unexpected', node, data, config, (data) => {
                            this.sendData(RED, node, data, config, 0);
                        });
                    });
                } else {
                    helper.emitAsyncEvent('prompt', node, data, config, (data) => {  
                        this.sendData(RED, node, data, config, outNumber); 
                    });
                }
    
            } else {
                this.sendData(RED, node, data, config, 0);
            }
        }
        this.manageMessage = function(RED, node, data, config, reply) {
    
            // Log activity
            try { setTimeout(function() { helper.trackActivities(node)},0); }
            catch(err) { console.log(err); }
            
            // Get conversation ID
            let convId = getConvId(data)
    
            // Prepare the prompt
            if (this.isPrompt(config)){
                delayCallback(convId, (prompt) => {
                    data.prompt = prompt;
                    this.prepareSend(RED, node, data, config);
                })
            }
    
            // Retrieve replies
            let replies = reply || this.buildReply(RED, node, data, config);
    
            if (!replies) { 
                this.prepareSend(RED, node, data, config); 
                return;
            }
            
            // Emit reply message
            data.reply = replies;
            data._replyid = node.id;
            helper.emitAsyncEvent('reply', node, data, config, (newData) => {
                helper.emitAsyncEvent('replied', node, newData, config, () => {})
                if (this.isPrompt(config)) return;
                this.prepareSend(RED, node, newData, config);
            });
        }
    }


    /**
     * Returns TRUE if the message is a prompt, false otherwise.
     * config   : the node configuration
     */
    isPrompt(config) {
        throw new TypeError('isPrompt Method should be implemented.');
    }

    /**
     * Returns the output number to send the message to.
     * RED      : the RED object
     * node     : the node
     * data     : the current node data
     * config   : the node configuration 
     */
    getOutputNumber(RED, node, data, config) {
        throw new TypeError('isExpectedPrompt Method should be implemented.');
    }

    /**
     * Build the reply array.
     * RED      : the RED object
     * node     : the node
     * data     : the current node data
     * config   : the node configuration 
     */
    buildReply(RED, node, data, config) {
    	throw new TypeError('buildReply Method should be implemented.');
    }

    /**
     * Removes one line selected from conditions
     * RED      : the RED object
     * node     : the node
     * data     : the current node data
     * config   : the node configuration
     * output   : the output number, 0 is unexpected
     */
    sendData(RED, node, data, config, output) {
    	throw new TypeError('sendData Method should be implemented.');
    }

}
