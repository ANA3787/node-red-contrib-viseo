'use strict';

const extend = require('extend');
const helper = require('node-red-viseo-helper');

// ------------------------------------------
//  BOT MESSAGE
// ------------------------------------------

const isReplyCarrier = exports.isReplyCarrier = (data, carrier) => {
    let message = data.reply;
    if (!message) return false;

    // Assume it's a reply to the 
    // current user address in the flow
    let address = helper.getByString(data, 'user.address', undefined)
    if (!address || address.carrier !== carrier) return false;

    message.address(address);
    return true;
}

const buildMessageFlow = exports.buildMessageFlow = (data, config) => {
    
    data = data || {}
    let msg  = data.message = data.message || {}
    
    if (config.source) msg.source = msg.source || config.source;
    if (config.agent)  msg.agent  = msg.agent  || config.agent;
    msg.attachments = msg.attachments || [];

    msg.address = msg.address || {}
    msg.address.carrier = msg.address.carrier || config.agent || config.source
    msg.address.conversation = msg.address.conversation || {}
    msg.address.conversation.id = helper.getByString(data, config.convId, msg.address.conversation.id);

    msg.user      = msg.user || {}
    msg.user.id   = helper.getByString(data, config.userId, msg.user.id);
    msg.user.name = helper.getByString(data, config.userName, msg.user.name || 'Unknow');

    data.user = data.user || {}
    data.user.address = data.user.address || {}
    data.user.profile = data.user.profile || {}
    extend(true, data.user, msg.user);
    extend(true, data.user.address, msg.address);

    if (config.payload){
        let payload = helper.getByString(data, config.payload, undefined);
        data.payload = payload
    }
    if (data.payload){ // warn can be tricky if it's an irevelant payload
        msg.text = msg.text || data.payload
    }

    data.context = data.context || {}
    if (config.context){
        let ctxt = helper.getByString(data, config.context, undefined);
        extend(true, data.context, ctxt);
    }
    
    return data;
}

// ------------------------------------------
//  CALLBACK DELAYED (PROMPT)
// ------------------------------------------

var DELAYED_CALLBACK = {}
const delayCallback = exports.delayCallback = (id, callback) => {
    if (!id) return;
    DELAYED_CALLBACK[id] = callback;
}

const hasDelayedCallback = exports.hasDelayedCallback = (id, data) => {
    if (!id) return;

    let callback = DELAYED_CALLBACK[id];
    if (undefined === callback) return false;

    delete DELAYED_CALLBACK[id];
    callback(data);
    return true;
}