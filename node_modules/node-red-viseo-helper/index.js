'use strict';

const fs     = require('fs');
const path   = require('path');
const vm     = require('vm');
const extend = require('extend');
const EventEmitter = require('events');

// ------------------------------------------
//  OVERRIDE
// ------------------------------------------

String.prototype.endsWith = function(suffix) {
    if (!suffix) return false;
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

String.prototype.startsWith = function(prefix) {
    if (!prefix) return false;
    return this.indexOf(prefix) === 0;
};

// ------------------------------------------
//  CONFIG
// ------------------------------------------

require('./lib/config.js').init();
exports.CONFIG = CONFIG; 

const mkpathsync = exports.mkpathsync = (dirpath, mode) => {
    dirpath = path.resolve(dirpath);

    if (typeof mode === 'undefined') {
        mode = parseInt('0777', 8) & (~process.umask());
    }

    try {
        if (!fs.statSync(dirpath).isDirectory()) {
            throw new Error(dirpath + ' exists and is not a directory');
        }
    } catch (err) {
        if (err.code === 'ENOENT') {
            mkpathsync(path.dirname(dirpath), mode);
            fs.mkdirSync(dirpath, mode);
        } else { throw err; }
    }
};

// ------------------------------------------
//  STRING
// ------------------------------------------


const getByString = exports.getByString = (obj, str, def) => { 
    if (!str) return def;
    let ctxt = { "data": obj , "value": undefined };
    const context = new vm.createContext(ctxt);
    const script  = new vm.Script("value = data."+str);
    try { script.runInContext(context); }
    catch(ex){ return def === undefined ? ex.message : def; }

    let result = ctxt.value === undefined ? def : ctxt.value;
    return result;
}

const setByString = exports.setByString = (obj, str, value, error) => {
    if (!str) return;
    let ctxt = { "data": obj, "value" : value };
    const context = new vm.createContext(ctxt);
    const script  = new vm.Script("data."+str+"=value"); 
    try { script.runInContext(context); }
    catch(ex){ 
        if (error) error(ex)
        else console.log(ex)
     }
}

const resolve = exports.resolve = (str, obj, def) => {
    if (str === undefined) return str;
    
    str = fastResolve(str)
    if (obj === undefined) return str;

    let rgxp = /\{([a-zA-Z0-9_'"\|\.\[\]])+\}/i;
    for (let i = 0 ; i < 100 &&  rgxp.test(str) ; i++){
        let match  = rgxp.exec(str)[0];
        let prop   = match.substring(1, match.length-1);

        //if {obj.a|obj.b} then use obj.a if exists, obj.b otherwise
        let split  = prop.split('|');
            def    = split.length > 1 ? getByString(obj, split[1], def) : def;
            prop   = split[0];

        //basic use case
        let value  = getByString(obj, prop, "");

        //just in case : check in config
        if(value === "") {
            value = global.CONFIG ? getByString(global.CONFIG, prop, def) : def;
        }
        value  = fastResolve(value);
        
        str = str.replace(match, value)
    }
    return str;
}

const fastResolve = (str) => {
    if (typeof str !== 'string') return str;
    if (str.indexOf('{cwd}') >= 0)
        str = str.replace('{cwd}', process.cwd());
    if (str.indexOf('{timestamp}') >= 0)
        str = str.replace('{timestamp}', Date.now());

    return str
}

// ------------------------------------------
//  EVENT
// ------------------------------------------

class NodeEmitter extends EventEmitter {}
const emitter = new NodeEmitter();

const emitEvent = exports.emitEvent  = (type, node, data, config) => {
    emitter.emit(type, node, config, data);
}

const listenEvent = exports.listenEvent  = (type, callback) => {
    emitter.addListener(type, callback);
}

const removeListener = exports.removeListener =  (type, callback) => {
    emitter.removeListener(type, callback);
}

const emitAsyncEvent = exports.emitAsyncEvent  = (type, node, data, config, callback) => {

    let listeners = emitter.listeners(type)
    if (!listeners || listeners.length == 0){
        return callback(data);
    }

    data._tmp = data._tmp || {}
    data._tmp['event_emitter'] = { callback: callback, config: config };   // Only one in a flow otherwise might loose it
    emitter.emit(type, node, data, config);
}

const fireAsyncCallback = exports.fireAsyncCallback = (data) => {
    if (!data._tmp) return;
    if (!data._tmp.event_emitter) return;

    let callback = data._tmp.event_emitter.callback;
    if (!callback) return;

    delete data._tmp.event_emitter;
    callback(data);
}

// ------------------------------------------
//  BOT MESSAGE
// ------------------------------------------

const buildMessageFlow = exports.buildMessageFlow = (data, config) => {
    
    data = data || {}
    let msg  = data.message = data.message || {}
    
    if (config.source) msg.source = config.source;
    if (config.agent)  msg.agent  = config.agent;
    msg.attachments = msg.attachments || [];

    msg.address = msg.address || {}
    msg.address.conversation = msg.address.conversation || {}
    msg.address.conversation.id = getByString(data, config.convId, msg.address.conversation.id);

    msg.user      = msg.user || {}
    msg.user.id   = getByString(data, config.userId, msg.user.id);
    msg.user.name = getByString(data, config.userName, msg.user.name || 'Unknow');

    data.user = data.user || {}
    data.user.address = data.user.address || {}
    data.user.profile = data.user.profile || {}
    extend(true, data.user, msg.user);
    extend(true, data.user.address, msg.address);

    if (config.payload){
        let payload = getByString(data, config.payload, undefined);
        data.payload = payload
    }
    if (data.payload){ // warn can be tricky if it's an irevelant payload
        msg.text = msg.text || data.payload
    }

    data.context = data.context || {}
    if (config.context){
        let ctxt = getByString(data, config.context, undefined);
        extend(true, data.context, ctxt);
    }
    
    return data;
}

// ------------------------------------------
//  CALLBACK DELAYED (PROMPT)
// ------------------------------------------

var DELAYED_CALLBACK = {}
const delayCallback = exports.delayCallback = (id, callback) => {
    if (!id) return;
    DELAYED_CALLBACK[id] = callback;
}

const hasDelayedCallback = exports.hasDelayedCallback = (id, data) => {
    if (!id) return;

    let callback = DELAYED_CALLBACK[id];
    if (undefined === callback) return false;

    delete DELAYED_CALLBACK[id];
    callback(data);
    return true;
}