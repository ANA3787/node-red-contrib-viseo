'use strict';
const fs   = require('fs');
const path = require('path');
const vm   = require('vm');


const getByString = exports.getByString = (obj, str, def) => {
    let ctxt = { "data": obj , "value": undefined };
    const context = new vm.createContext(ctxt);
    const script  = new vm.Script("value = data."+str);
    try { script.runInContext(context); }
    catch(ex){ return def || ex.message; }
    return ctxt.value;
}

const setByString = exports.setByString = (obj, str, value) => {
    let ctxt = { "data": obj };
    const context = new vm.createContext(ctxt);
    const script  = new vm.Script("data."+str+"="+value);
    try { script.runInContext(context); }
    catch(ex){ /* can't log */ }
}

const resolve = exports.resolve = (obj, str, def) => {
    let rgxp = /\{([a-zA-Z0-9_\.\[\]])+\}/i;
    str = str.replace('{cwd}', process.cwd());
    str = str.replace('{timestamp}', Date.now());
    if (obj === undefined) return str;
    
    for (let i = 0 ; i < 100 &&  rgxp.test(str) ; i++){
        let match  = rgxp.exec(str)[0]; 
        let prop   = match.substring(1, match.length-1)
        let value  = getByString(obj, prop, def)
        str = str.replace(match, value)
    }
    
    return str;
}

const mkpathsync = exports.mkpathsync = (dirpath, mode) => {
    dirpath = path.resolve(dirpath);

    if (typeof mode === 'undefined') {
        mode = parseInt('0777', 8) & (~process.umask());
    }

    try {
        if (!fs.statSync(dirpath).isDirectory()) {
            throw new Error(dirpath + ' exists and is not a directory');
        }
    } catch (err) {
        if (err.code === 'ENOENT') {
            mkpathsync(path.dirname(dirpath), mode);
            fs.mkdirSync(dirpath, mode);
        } else { throw err; }
    }
};
